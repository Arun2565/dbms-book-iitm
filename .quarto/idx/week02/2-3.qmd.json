{"title":"2.3 Intro to SQL/1","markdown":{"yaml":{"title":"2.3 Intro to SQL/1"},"headingText":"History of SQL","containsRefs":false,"markdown":"\n\n\nIBM developed Structured English Query Language as a part of R project. Later, it was named as SQL in the 1970s and 1980s. In 1989 , integrity constraints was introduced. In 1992, it was standardised using ISO 9075 standard, this is the major revision and we are following this using some revisions.\n\nnaturally SQL 1999 you can understand that this was getting close to\nyear 2000. So, everybody was concerned with y2k. So, the naming of the standard also changed\nin the y2k four-digit year format.\n\nThis added several of very useful features like matching of regular expressions, recursive\nqueries, that is which we will see is not possible in pure relational algebra that is transitive\nclosure was provided as a part of SQL then triggers, support for procedural and control\nstatements, which are SQL as I mentioned, or query languages, as I mentioned are declarative,\nbut some procedural support is also provided.\nArrays, structure types and most importantly, first a formal embedding mechanism was given in\nSQL, so that you can embed SQL queries in Java, which is called SQL will be and you can\nembed Java in SQL, which is called SQL JRT. Both of these embeddings are possible so that you\ncan choose which part of the task you would like to do as relational operations or database\noperations and which part you would like to do in a standard programming language like Java.\n2003 standard also added a very significant feature of XML. We will talk about XML being a\nstandard format for Information Interchange. So, that was added in 2003 and in 2006, a full\nfunctionality of XML including, importing, storing, manipulating, exporting, publishing, all\nthese were added. Subsequently several small but important updates continued to happen in SQL\nand the latest version of SQL is 2019.\n\n#### Alternatives to SQL\n\nPrimarily SQL is used for most cases. There are some frontend softwares made which make SQL easy to write in different languages like Lisp, Haskell, Ruby , Scala.\n\n- Derivates using SQL : There are many derived query languages from SQL. But the most effective which stands out is **SPARQL**. \n\n<br>\n\nSPARQL has a recursive acronymn SPARQL Protocol and RDF Query Language. This has been used by the query languages for several NOSQL systems - particularly the Graph Databases that uses RDF (Resource Descriptive Framework) to store.\n\n\n## DDL - Data Definition Language \n\n\n### Domain Types in SQL \n\nThere are various types in SQL : \n\n- varchar(n) : In varchar(n), it can have any length upto 'n'. But in char(n) it should have exactly 'n' number of characters.\n- char(n). Fixed length character string, with user-specified length n\n- smallint : Small integer (a machine-dependent subset of the integer domain type)\n- numeric(p, d) : Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32)real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision\n- float(n): Floating point number, with user-specified precision of at least n digits\n\n\n## Create Table \n\nCreating Schema is done using the \"Create Table \" command in  SQL. We have to create the table with attributes and their types respectively.\n\n```\nCREATE TABLE INSTRUCTOR \n(ID CHAR(5),\nNAME VARCHAR(20),\nDEPT_NAME VARCHAR(20),\nSALARY NUMERIC(8,2))\n```\n\nHere for the salary attribute numeric(8,2) means that it take up to 8 digits, and two decimals, after the period.\n\n### Integrity Constraints \n\nThese are used to specify that a field should not contain NULL values.\n- We should mention the Primary Key, primary key by default is not null.\n- We should maintain the Foriegn Key and its reference.\n\n```\nCREATE TABLE INSTRUCTOR \n(ID CHAR(5),\nNAME VARCHAR(20) NOT NULL,\nDEPT_NAME VARCHAR(20),\nSALARY NUMERIC(8,2)\nPRIMARY KEY (ID),\nFOREIGN KEY (DEPT_NAME) references department \n)\n```\n\n#### Update Table \n\nWe can update table using the following operations : \n\n- Insert : Insert instance into a table. Ex : insert into instructor values('101','Smith','Maths',50000)\n- Delete : We can remove all the tuples from a table.\n- Drop Table : We can delete the whole table and it will be removed from data dictionary itself.\n- Alter Table : Where we can add an attribute in a table. \n```\nalter table r add a \n```\nwhere add a is used to  edit the schema. While adding the attributes , initially these should be nullable.\n\n```\nalter table r drop A \n\n```\n\n## DML : Data Manipulation Language \n\n\nBasic SQL Query Structure is in the form : \n<br>\n\n```\nselect A1,A2,...An\nfrom r1,r2,...rn\nwhere P\n\n```\n\nwhere Ai represents an attribute from ri' s.\nri represent a relation\nP is a predicate , which is nothing but a boolean condition.\n\n\n### SELECT CLAUSE \n\nSelect Clause mentions the list of attributes required in the query. It corresponds to the projection operation in Relational Algebra. \n\nSQL names are case insensitive.\n\nSQL will show duplicate entries in the result. To display unique values without duplicates, we can use the \"distinct\" keyword which will remove the duplicates.\n\n```\nselect distinct dept_name from instructor\n```\n<br>\nTo show the duplicates explicitly we can use the all command.\n\n```\nselect all dept_name from instructor\n\n```\n\n- An asterisk in the select clause uses all the attributes.\n```\nselect * from instructor\n\n```\n\n- We can select a literal using the select clause.\n```\nselect '437'\n```\n\n- We can use the arithmetic expressions in the Select clause and even rename it using the as clause.\n\n```\nselect ID,name,salary/12 as monthly_salary\n```\n\n## WHERE Clause \n\nWHERE Clause is used to specify the conditions that should be resulted or displayed. The result of the predicate is always True or False.\n- WHERE Clause corresponds to selection predicate of the relational algebra.\n\n```\nselect name \nfrom instructor \nwhere dept_name = 'Comp_Sci'\n```\n\n## FROM Clause\n\nFROM Clause tells us the scope of the relations we are dealing with from one or multiple tables.\nThis corresponds to the Cartesian Product operation in the Relational Algebra.\n```\nselect * \nfrom instructor , teaches\n\n```\nNote : We have to put a WHERE Clause to make it effective and simpler.\n","srcMarkdownNoYaml":"\n\n## History of SQL \n\nIBM developed Structured English Query Language as a part of R project. Later, it was named as SQL in the 1970s and 1980s. In 1989 , integrity constraints was introduced. In 1992, it was standardised using ISO 9075 standard, this is the major revision and we are following this using some revisions.\n\nnaturally SQL 1999 you can understand that this was getting close to\nyear 2000. So, everybody was concerned with y2k. So, the naming of the standard also changed\nin the y2k four-digit year format.\n\nThis added several of very useful features like matching of regular expressions, recursive\nqueries, that is which we will see is not possible in pure relational algebra that is transitive\nclosure was provided as a part of SQL then triggers, support for procedural and control\nstatements, which are SQL as I mentioned, or query languages, as I mentioned are declarative,\nbut some procedural support is also provided.\nArrays, structure types and most importantly, first a formal embedding mechanism was given in\nSQL, so that you can embed SQL queries in Java, which is called SQL will be and you can\nembed Java in SQL, which is called SQL JRT. Both of these embeddings are possible so that you\ncan choose which part of the task you would like to do as relational operations or database\noperations and which part you would like to do in a standard programming language like Java.\n2003 standard also added a very significant feature of XML. We will talk about XML being a\nstandard format for Information Interchange. So, that was added in 2003 and in 2006, a full\nfunctionality of XML including, importing, storing, manipulating, exporting, publishing, all\nthese were added. Subsequently several small but important updates continued to happen in SQL\nand the latest version of SQL is 2019.\n\n#### Alternatives to SQL\n\nPrimarily SQL is used for most cases. There are some frontend softwares made which make SQL easy to write in different languages like Lisp, Haskell, Ruby , Scala.\n\n- Derivates using SQL : There are many derived query languages from SQL. But the most effective which stands out is **SPARQL**. \n\n<br>\n\nSPARQL has a recursive acronymn SPARQL Protocol and RDF Query Language. This has been used by the query languages for several NOSQL systems - particularly the Graph Databases that uses RDF (Resource Descriptive Framework) to store.\n\n\n## DDL - Data Definition Language \n\n\n### Domain Types in SQL \n\nThere are various types in SQL : \n\n- varchar(n) : In varchar(n), it can have any length upto 'n'. But in char(n) it should have exactly 'n' number of characters.\n- char(n). Fixed length character string, with user-specified length n\n- smallint : Small integer (a machine-dependent subset of the integer domain type)\n- numeric(p, d) : Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32)real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision\n- float(n): Floating point number, with user-specified precision of at least n digits\n\n\n## Create Table \n\nCreating Schema is done using the \"Create Table \" command in  SQL. We have to create the table with attributes and their types respectively.\n\n```\nCREATE TABLE INSTRUCTOR \n(ID CHAR(5),\nNAME VARCHAR(20),\nDEPT_NAME VARCHAR(20),\nSALARY NUMERIC(8,2))\n```\n\nHere for the salary attribute numeric(8,2) means that it take up to 8 digits, and two decimals, after the period.\n\n### Integrity Constraints \n\nThese are used to specify that a field should not contain NULL values.\n- We should mention the Primary Key, primary key by default is not null.\n- We should maintain the Foriegn Key and its reference.\n\n```\nCREATE TABLE INSTRUCTOR \n(ID CHAR(5),\nNAME VARCHAR(20) NOT NULL,\nDEPT_NAME VARCHAR(20),\nSALARY NUMERIC(8,2)\nPRIMARY KEY (ID),\nFOREIGN KEY (DEPT_NAME) references department \n)\n```\n\n#### Update Table \n\nWe can update table using the following operations : \n\n- Insert : Insert instance into a table. Ex : insert into instructor values('101','Smith','Maths',50000)\n- Delete : We can remove all the tuples from a table.\n- Drop Table : We can delete the whole table and it will be removed from data dictionary itself.\n- Alter Table : Where we can add an attribute in a table. \n```\nalter table r add a \n```\nwhere add a is used to  edit the schema. While adding the attributes , initially these should be nullable.\n\n```\nalter table r drop A \n\n```\n\n## DML : Data Manipulation Language \n\n\nBasic SQL Query Structure is in the form : \n<br>\n\n```\nselect A1,A2,...An\nfrom r1,r2,...rn\nwhere P\n\n```\n\nwhere Ai represents an attribute from ri' s.\nri represent a relation\nP is a predicate , which is nothing but a boolean condition.\n\n\n### SELECT CLAUSE \n\nSelect Clause mentions the list of attributes required in the query. It corresponds to the projection operation in Relational Algebra. \n\nSQL names are case insensitive.\n\nSQL will show duplicate entries in the result. To display unique values without duplicates, we can use the \"distinct\" keyword which will remove the duplicates.\n\n```\nselect distinct dept_name from instructor\n```\n<br>\nTo show the duplicates explicitly we can use the all command.\n\n```\nselect all dept_name from instructor\n\n```\n\n- An asterisk in the select clause uses all the attributes.\n```\nselect * from instructor\n\n```\n\n- We can select a literal using the select clause.\n```\nselect '437'\n```\n\n- We can use the arithmetic expressions in the Select clause and even rename it using the as clause.\n\n```\nselect ID,name,salary/12 as monthly_salary\n```\n\n## WHERE Clause \n\nWHERE Clause is used to specify the conditions that should be resulted or displayed. The result of the predicate is always True or False.\n- WHERE Clause corresponds to selection predicate of the relational algebra.\n\n```\nselect name \nfrom instructor \nwhere dept_name = 'Comp_Sci'\n```\n\n## FROM Clause\n\nFROM Clause tells us the scope of the relations we are dealing with from one or multiple tables.\nThis corresponds to the Cartesian Product operation in the Relational Algebra.\n```\nselect * \nfrom instructor , teaches\n\n```\nNote : We have to put a WHERE Clause to make it effective and simpler.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":false,"output-file":"2-3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","theme":"cosmo","title":"2.3 Intro to SQL/1"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}