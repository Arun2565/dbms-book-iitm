{"title":"2.1 Intro to Relational Model/1","markdown":{"yaml":{"title":"2.1 Intro to Relational Model/1"},"headingText":"Example of a Relation","containsRefs":false,"markdown":"\n\n\n\nA column is defined as an **attribute**. \nA row is defined as a **tuple** or a record.\n\n\n## Attribute Types \n\n- Student has attributes and is related by Roll No, First Name, Last Name , DOB, Passport, Aadhar, Department relation.\n\n- Roll No : Alphanumeric String \n- First Name, Last Name :   Alpha string \n- DOB : Date \n- Passport : String - nullable (optional)\n- Aadhar : 12 digit number \n- Department : Alpha String \n\n\n- Attribute values should be atomic and indivisible. EX : indivisible meaning we cannot combine first name and last name to one and make it an attribute.\n\n\n## Relation Schema and Instance \n\nSchema is the attributes and the type of attributes the table can take.\nInstance is the actual values and tuples that the table holds.\n\nSchema can be mathematically represented as a relation.\n\nA1, A2, .... An are the attributes.\nR = (A1,A2,....An) is a relation schema.\n\nEx : Instructor = (ID,name,dept_name,salary)\nThe instructor has the relation schema with these four attributes.\n\n- D1,D2,....Dn are the domains of the respective attributes.\n\n- A relation is a subset of (D1,D2,....Dn) .\n- The relational instance is the table of actual set of values.\n\n\n- The order of tuples in the table or the relation is irrelevant.\n- There should be no two rows/ tuples that are identical. Every tuple has to be distinct from every other tuple. There should be atleast one field where the value should vary.\nA relation is nothing but a set, so it does not have an order and does not take duplicate values.\n\n## Keys \n\nEvery row/ tuple must be unique and identifiable. Instead of knowing all the values to identify every row, we can work with subset of attributes which can uniquely indentify every row.\n\n- Let K be a subset of R, where R is a set of attributes in the relation.\n\nEvery attribute has a unique key and they will be called a Super key, unless we show there is no subset smaller than this.\nSuperkey is a candidate key, when k is minimal.\n\nMinimality - Suppose 'k' is a candidate key and no subset of 'k' is a Superkey, then we will call this as a minimal set or a candidate key.\n\nEx :  Both ID and ID Names is a superkey and not a candidate key.\n{ID} -> Candidate Key , there is no subset.\n{ID,name} -> Super Key\n\n- There may be one or multiple candidate keys. From the primary keys, we can choose one primary key.\n\n- Surrogate key in a database is a unique identifier for either an entity in the modeled world or an object in the database.\nEx : A customer orders the same item , same quantity, at different times so they cannot be treated as the same transactions. So, we synthetically generate a key that is the order number. \n- Synthetically generated data only at the time of transaction are known as surrogate key. These keys have very short lifetime, in this case the order number exists only until the order is placed and delivered. These values are not changed. In the collection of orders it will be unique.\n\nRoll no and EMP_ID in contrast are permanent in nature. The roll no. remains valid as long as the person is there. These uniquely identify a unique entity in the world.\n\n: Table 2.1: Attributes and their keys\n\n| Attribute| Key |\n|-------|-------------|\n| `Roll_No, {Roll_No, DOB}` |Super Key |\n| `Roll_No, {First Name, Last Name}, Aadhar` | Candidate Key|\n| `Passport`   | Cannot be a key, as it nullable and optional |\n\n#### Choosing a Primary Key\n\n\nFor the student table, choosing primary key has two options : Roll No, Aadhar ID.\n\nThe roll no conveys a lot of information of the student.  Ex : Roll No : 14CS92P01\n\n14: Year of Admission\nCS : Department of CS\n92 : Category of student\nP : Type of admission\n01 : Serial no. # No. of people in a class, etc.\n\nAll these five types of parameters are put together to create a unique key.\n\n- Secondary Keys :  Candidate keys which are not primary are called secondary keys. \nEx : {First Name, Last Name}, Aadhar.\n\n- Simple Key : A key which consists of a single attribute.\n\n- Candidate Keys : A Candidate Key is a key which has more than one component. \nEx : {First Name, Last Name}\n\n\n- Foreign Key : When a particular attribute is a key in a different table.\nEx : Students table -> Roll No {Primary Key}, Courses Table -> Course {Primary Key}, Enrollment table -> An attribute which is a key in a different table, here Roll No is a primary key in the students table, but that is not the case all times.\n\n\n## Relational Query Languages \n\nProcedural Programming tells us how we get a value.\nDeclarative Language tells what the answer should be. This style is useful for relational query.\n\nThe relational models are : \n\n1. Relational Algebra \n2. Tuple Relational Calculus\n3. Domain Relational Calculus\n\n","srcMarkdownNoYaml":"\n\n### Example of a Relation \n\n\nA column is defined as an **attribute**. \nA row is defined as a **tuple** or a record.\n\n\n## Attribute Types \n\n- Student has attributes and is related by Roll No, First Name, Last Name , DOB, Passport, Aadhar, Department relation.\n\n- Roll No : Alphanumeric String \n- First Name, Last Name :   Alpha string \n- DOB : Date \n- Passport : String - nullable (optional)\n- Aadhar : 12 digit number \n- Department : Alpha String \n\n\n- Attribute values should be atomic and indivisible. EX : indivisible meaning we cannot combine first name and last name to one and make it an attribute.\n\n\n## Relation Schema and Instance \n\nSchema is the attributes and the type of attributes the table can take.\nInstance is the actual values and tuples that the table holds.\n\nSchema can be mathematically represented as a relation.\n\nA1, A2, .... An are the attributes.\nR = (A1,A2,....An) is a relation schema.\n\nEx : Instructor = (ID,name,dept_name,salary)\nThe instructor has the relation schema with these four attributes.\n\n- D1,D2,....Dn are the domains of the respective attributes.\n\n- A relation is a subset of (D1,D2,....Dn) .\n- The relational instance is the table of actual set of values.\n\n\n- The order of tuples in the table or the relation is irrelevant.\n- There should be no two rows/ tuples that are identical. Every tuple has to be distinct from every other tuple. There should be atleast one field where the value should vary.\nA relation is nothing but a set, so it does not have an order and does not take duplicate values.\n\n## Keys \n\nEvery row/ tuple must be unique and identifiable. Instead of knowing all the values to identify every row, we can work with subset of attributes which can uniquely indentify every row.\n\n- Let K be a subset of R, where R is a set of attributes in the relation.\n\nEvery attribute has a unique key and they will be called a Super key, unless we show there is no subset smaller than this.\nSuperkey is a candidate key, when k is minimal.\n\nMinimality - Suppose 'k' is a candidate key and no subset of 'k' is a Superkey, then we will call this as a minimal set or a candidate key.\n\nEx :  Both ID and ID Names is a superkey and not a candidate key.\n{ID} -> Candidate Key , there is no subset.\n{ID,name} -> Super Key\n\n- There may be one or multiple candidate keys. From the primary keys, we can choose one primary key.\n\n- Surrogate key in a database is a unique identifier for either an entity in the modeled world or an object in the database.\nEx : A customer orders the same item , same quantity, at different times so they cannot be treated as the same transactions. So, we synthetically generate a key that is the order number. \n- Synthetically generated data only at the time of transaction are known as surrogate key. These keys have very short lifetime, in this case the order number exists only until the order is placed and delivered. These values are not changed. In the collection of orders it will be unique.\n\nRoll no and EMP_ID in contrast are permanent in nature. The roll no. remains valid as long as the person is there. These uniquely identify a unique entity in the world.\n\n: Table 2.1: Attributes and their keys\n\n| Attribute| Key |\n|-------|-------------|\n| `Roll_No, {Roll_No, DOB}` |Super Key |\n| `Roll_No, {First Name, Last Name}, Aadhar` | Candidate Key|\n| `Passport`   | Cannot be a key, as it nullable and optional |\n\n#### Choosing a Primary Key\n\n\nFor the student table, choosing primary key has two options : Roll No, Aadhar ID.\n\nThe roll no conveys a lot of information of the student.  Ex : Roll No : 14CS92P01\n\n14: Year of Admission\nCS : Department of CS\n92 : Category of student\nP : Type of admission\n01 : Serial no. # No. of people in a class, etc.\n\nAll these five types of parameters are put together to create a unique key.\n\n- Secondary Keys :  Candidate keys which are not primary are called secondary keys. \nEx : {First Name, Last Name}, Aadhar.\n\n- Simple Key : A key which consists of a single attribute.\n\n- Candidate Keys : A Candidate Key is a key which has more than one component. \nEx : {First Name, Last Name}\n\n\n- Foreign Key : When a particular attribute is a key in a different table.\nEx : Students table -> Roll No {Primary Key}, Courses Table -> Course {Primary Key}, Enrollment table -> An attribute which is a key in a different table, here Roll No is a primary key in the students table, but that is not the case all times.\n\n\n## Relational Query Languages \n\nProcedural Programming tells us how we get a value.\nDeclarative Language tells what the answer should be. This style is useful for relational query.\n\nThe relational models are : \n\n1. Relational Algebra \n2. Tuple Relational Calculus\n3. Domain Relational Calculus\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":false,"output-file":"2-1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","theme":"cosmo","title":"2.1 Intro to Relational Model/1"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}